<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vuex学习日记]]></title>
    <url>%2F2018%2F03%2F05%2FVuex%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[学习vue全家桶中的状态管理工具 —— Vuex 挺久之前就开始学习vue了，vue全家桶中的vuex也有稍微了解，但是那个时候还没有对其进行更熟悉的了解吧，今天就重新认真学习了下。 看看官方对Vuex的解释， Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 在学习之后，个人对其也有了自己的理解，我觉得可以理解为在data中的属性需要共享给其他vue组件使用的部分。简单的说就是data中需要共用的属性。比如做一个购物车，那么购物车的内容就需要在不同页面中进行保留和传递，这时候就可以使用Vuex对其进行集中管理。在此之前，我们都是用父子组件互相传值来完成的。 在官方文档中，会学到 Vue 的一些核心概念，深入理解所有的概念对于使用 Vuex 来说是必要的。接下来我自己通过一个小案例来弄清楚这些核心概念，当做一个总结了。 起步第一步先通过vue-cli脚手架工具搭建起vue项目运行的环境，这里就不多说了。接着通过npm安装vuex。本人用的是VScode，所以自带了终端，直接ctrl+`打开终端，输入下面命令行： 1npm install vuex --save vuex在开发过程需要用到，所以必须加上--save选项。 接着新建store.js文件，将vue和vuex导入，并且使用vuex。 1234import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex); 接着创建一个仓库state（我自己的理解 - -），再放入一个变量count。（做一个小计数器） 1234//state理解为存放共享状态的仓库const state = &#123; count: 1&#125; 然后将内容导出： 123export default new Vuex.Store(&#123; state&#125;) state在component文件夹下创建Count.vue模板文件。 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt;&lt;hr/&gt; &lt;h3&gt;&#123;&#123;$store.state.count&#125;&#125; --- &#123;&#123;count&#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import store from &apos;../vuex/store.js&apos;; //解构赋值得到mapState import &#123; mapState &#125; from &apos;vuex&apos;; export default &#123; data() &#123; return &#123; msg: &apos;Hello Vuex&apos; &#125; &#125;, //利用mapState方法可以简化拼写，如$store.state.count简化为count //最容易理解的写法为： // computed: &#123; // count() &#123; // return this.$store.state.count; // &#125; // &#125;, computed: &#123; ...mapState([&apos;count&apos;]) &#125;, store &#125;&lt;/script&gt;&lt;style lang=&quot;&quot;&gt; &lt;/style&gt; 一开始就需要引入并注册store，这点很重要。其中利用mapState辅助函数帮助我们生成计算属性。如上HTML代码中的$store.state.count可以通过mapState直接简化为count。只需从vuex中解构赋值得到mapState，再在computed中做映射。由于mapState 函数返回的是一个对象，所以可以通过ES6新增的对象展开运算符...将它与局部计算属性混合使用。 mutations接下来为计数器增加两个按钮，一加一减。Count.vue中的HTML代码如下： 123456789101112&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt;&lt;hr/&gt; &lt;h3&gt;&#123;&#123;$store.state.count&#125;&#125; --- &#123;&#123;count&#125;&#125;&lt;/h3&gt; &lt;!--新增--&gt; &lt;p&gt; &lt;button @click=&quot;$store.commit(&apos;add&apos;,5)&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;$store.commit(&apos;reduce&apos;)&quot;&gt;-&lt;/button&gt; &lt;/p&gt; &lt;!--新增--&gt; &lt;/div&gt;&lt;/template&gt; 上面增加了两个方法add和reduce，接下来在store.js中分别实现： 123456789//mutations用于改变state中的状态值const mutations = &#123; add(state, n) &#123; state.count += n; &#125;,//可传第二个参数 reduce(state) &#123; state.count-- &#125;,&#125; 可以看到，这里使用mutations。更改 Vuex 的 store 中的状态的唯一方法是提交 mutation，即上面可见的，需要调用$store.commit()方法。参数则为函数。同时也要像前面state一样，导出mutations。 如果我们希望直接通过@click=&#39;add()&#39;这样就可以直接调用方法，而不需要利用$store.commit()时，我们可以使用mapMutations。在Count.vue中，同理先从vuex中解构赋值得到mapMutations，然后在methods中进行方法的映射： 12//将this.add()和this.reduce()分别映射为this.$store.commit('add')和this.$store.commit('reduce') methods: mapMutations(['add', 'reduce']), 此时，在Count.vue中我们便可以直接调用函数，跟没引用vuex插件一样。 12&lt;button @click="add"&gt;+&lt;/button&gt;&lt;button @click="reduce"&gt;-&lt;/button&gt; getters接着是getters。getters从表面是获得的意思，可以把他看作在获取数据之前进行的一种再编辑,相当于对数据的一个过滤和加工。你可以把它看作store.js的计算属性。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 在store.js做如下操作： 123456//getters用于计算过滤const getters = &#123; count: (state) =&gt; &#123; return state.count += 100; &#125;&#125; 同时导出getters。接着先从vuex中解构赋值得到mapGetters，然后computed中，同理使用扩展运算符： 123computed: &#123; ...mapGetters(['count'])&#125; 此时跟普通Vue实例中的computed一样，当需要被计算的值发送变化时，计算属性先做出变化，改变当前的值。 在学习的过程中还有两个概念——action和module。 action : actions和之前讲的mutations功能基本一样，不同点是，actions是异步的改变state状态，而mutations是同步改变状态。 module : 状态管理器的模块组操作。随着项目的复杂性增加，我们共享的状态越来越多，这时候我们就需要把我们状态的各种操作进行一个分组，分组后再进行按组编写。 这里有空的话会再去看官方文档或者技术胖的博客，进行一个更系统的学习。]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于学习微信小程序的一些记录]]></title>
    <url>%2F2018%2F03%2F02%2F%E5%85%B3%E4%BA%8E%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[关于微信小程序自己的一些学习历程记录一下吧。 上个学期，经过一个朋友介绍，我有幸参加了学校“挑战杯”其中一个小组的项目，负责该项目的微信小程序部分。那时候我一点都不了解小程序，通过自己慢慢学习摸索，帮助该团队完成了这个项目1.0版本的小程序端后，退出该项目团队。接下来就我个人的学习经历什么的随便写写，算是一种记录。该项目是制作一个健身器材。就我个人而言，我知道健身有在健身房进行大汗淋漓的健身，也有在体侧房进行测量性质之类的健身，我们的项目就是属于后者，制作一个能测量出被测量者的各方面力量。当时硬件方面已经成熟，上位机就绪，可以在机器上进行实验。后台小组以及我负责的小程序都是后来加入的。说回小程序，此处应有图，不过这个项目将来要上市的（团队负责人很有生意头脑），所以意思意思就好。以下的图是在小程序开发助手和web开发者工具看的。 关于登录来说说小程序的登录。引用小程序官方文档的登录时序图，整个登录流程基本如下图所示：该图中，小程序指的就是我们使用小程序框架写的代码部分，第三方服务器一般就是我们自己的后台服务程序，微信服务器是微信官方的API服务器。 在客户端获取当前登录微信用户的登录凭证(code)我们可以使用wx.login()方法得到一个登录凭证，获取该凭证是小程序登录的第一步。 接着可以在小程序的App代码中发起登录凭证请求，也可以在其他任何Page页面代码中发起登录凭证请求。 1234567891011121314App(&#123; onLaunch: function() &#123; wx.login(&#123; success: function(res) &#123; var code = res.code; if (code) &#123; console.log('获取用户登录凭证：' + code); &#125; else &#123; console.log('获取用户登录态失败：' + res.errMsg); &#125; &#125; &#125;); &#125;&#125;) 获取唯一标识(openid)和会话密钥(session_key)使用wx.request()方法，请求后台的API，并将登录凭证(code)传递过去。例如在我们前面代码的基础上增加： 12345678910111213141516171819202122App(&#123; onLaunch: function() &#123; wx.login(&#123; success: function(res) &#123; var code = res.code; if (code) &#123; console.log('获取用户登录凭证：' + code);// --------- 发送凭证 ------------------ wx.request(&#123; url: 'https://www.yourAPI.com/user', data: &#123; code: code &#125; &#125;)// ------------------------------------ &#125; else &#123; console.log('获取用户登录态失败：' + res.errMsg); &#125; &#125; &#125;); &#125;&#125;) 你的后台服务(/user)接着需要使用这个传递过来的登录凭证，去调用微信接口换取openid和session_key，接口地址格式如下所示： 1https://api.weixin.qq.com/sns/jscode2session?`appid=APPID`&amp;`secret=SECRET`&amp;`js_code=JSCODE`&amp;grant_type=authorization_code 其中APPID和SECRET则是申请小程序时候就给出的，可以去小程序后台管理界面查看，JSCODE则是小程序端传递过来的登录凭证code。 后台代码这里不是我负责，所以没有贴出。不过其实大同小异。 你自己的后台代码如果成功执行的话，就可以得到openid和session_key。这个信息就是当前微信账户在微信服务器那边的登录态了。至此登录部分就完成了。 其他之后就是一些图片上传啊，UI的设计啥的，这些去微信小程序官方文档都能找得到。UI则采用了WeUI（https://weui.io/）。小程序也采用了数据驱动的方式操作文档，这是很棒的，跟现有的流行框架，如VUE，Angular一样，同时也支持ES6语法。 总之，这个项目让我体验到前后台合作开发的流程，算是有收获。继续学习下去吧。]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mongo学习笔记（三）]]></title>
    <url>%2F2018%2F02%2F23%2Fmongo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[学习mongoDB的查询(find)操作。 今天照着技术胖的博客继续学习了mongoDB的查询操作。 首先先把例子前提搭好：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130 var workmate1 = &#123; name: 'JSPang', age: 33, sex: 1, job: '前端', skill: &#123; skillOne: 'HTML+CSS', skillTwo: 'JavaScript', skillThree: 'PHP' &#125;, regeditTime: new Date(), interest: []&#125;var workmate2 = &#123; name: 'ShengLei', age: 31, sex: 1, job: 'JAVA后端', skill: &#123; skillOne: 'HTML+CSS', skillTwo: 'J2EE', skillThree: 'PPT' &#125;, regeditTime: new Date(), interest: []&#125;var workmate3 = &#123; name: 'MinJie', age: 18, sex: 0, job: 'UI', skill: &#123; skillOne: 'PhotoShop', skillTwo: 'UI', skillThree: 'PPT' &#125;, regeditTime: new Date(), interest: []&#125;var workmate4 = &#123; name: 'XiaoWang', age: 25, sex: 1, job: 'UI', skill: &#123; skillOne: 'PhotoShop', skillTwo: 'UI', skillThree: 'PPT' &#125;, regeditTime: new Date(), interest: []&#125;var workmate5 = &#123; name: 'LiangPeng', age: 28, sex: 1, job: '前端', skill: &#123; skillOne: 'HTML+CSS', skillTwo: 'JavaScript', &#125;, regeditTime: new Date(), interest: []&#125;var workmate6 = &#123; name: 'HouFei', age: 25, sex: 0, job: '前端', skill: &#123; skillOne: 'HTML+CSS', skillTwo: 'JavaScript', &#125;, regeditTime: new Date(), interest: []&#125;var workmate7 = &#123; name: 'LiuYan', age: 35, sex: 0, job: '美工', skill: &#123; skillOne: 'PhotoShop', skillTwo: 'CAD', &#125;, regeditTime: new Date(), interest: []&#125;var workmate8 = &#123; name: 'DingLu', age: 20, sex: 0, job: '美工', skill: &#123; skillOne: 'PhotoShop', skillTwo: 'CAD', &#125;, regeditTime: new Date(), interest: []&#125;var workmate9 = &#123; name: 'JiaPeng', age: 29, sex: 1, job: '前端', skill: &#123; skillOne: 'HTML+CSS', skillTwo: 'JavaScript', skillThree: 'PHP' &#125;, regeditTime: new Date(), interest: []&#125;var workmate10 = &#123; name: 'LiJia', age: 26, sex: 0, job: '前端', skill: &#123; skillOne: 'HTML+CSS', skillTwo: 'JavaScript', skillThree: 'PHP' &#125;, regeditTime: new Date(), interest: []&#125;var db = connect('company');var workmateArray = [workmate1, workmate2, workmate3, workmate4, workmate5, workmate6, workmate7, workmate8, workmate9, workmate10];db.workmate.insert(workmateArray);print('[SUCCESS]：The data was inserted successfully'); 简单查找1234//简单查找db.workmate.find();//根据条件查找db.workmate.find(&#123; "skill.skillOne": "HTML+CSS" &#125;, &#123; name: true &#125;); 不等修饰符 小于($lt):英文全称 less-than 小于等于($lte)：英文全称 less-than-equal 大于($gt):英文全称 greater-than 大于等于($gte):英文全称 greater-than-equal 不等于($ne):英文全称 not-equal 可以根据不等修饰符进行查询。 12345//查找年龄小于30大于25岁的人db.workmate.find( &#123; age: &#123; $lte: 30, $gte: 25 &#125; &#125;, &#123; name: true, age: true, "skill.skillOne": true, _id: false &#125;) $in修饰符可以进行一个键多个值的查询。 12345//查找年龄为25和33的人db.workmate.find( &#123; age: &#123; $in: [25, 33] &#125; &#125;, &#123; name: 1, _id: 0 &#125;) $or修饰符同时进行多个键值的查询。或逻辑。 12345678910//查找年龄大于30或第三项技能为PHP的人db.workmate.find( &#123; $or: [ &#123; age: &#123; $gte: 30 &#125; &#125;, &#123; "skill.skillThree": "PHP" &#125; ] &#125;, &#123; name: 1, age: 1, "skill.skillThree": 1, _id: 0 &#125;) $and修饰符同时进行多个键值的查询。与逻辑。 12345678910//查找年龄大于30并且第三项技能为PHP的人db.workmate.find( &#123; $and: [ &#123; age: &#123; $gte: 30 &#125; &#125;, &#123; "skill.skillThree": "PHP" &#125; ] &#125;, &#123; name: 1, age: 1, "skill.skillThree": 1, _id: 0 &#125;) find在js文本中的使用使用find进行查询也可以像之前使用update操作一样，将语句写在一个js文件中，然后通过load方法执行该js文件即可。 1234567var db = connect('company');var result = db.workmate.find();while(result.hasNext()) &#123; printjson(result.next());&#125;//打印查询到的所有记录 除了使用while循环，也可以使用forEach，更加方便优雅。 123456var db = connect('company');var result = db.workmate.find();result.forEach(function(res) &#123; printjson(res);&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mongo学习笔记（二）]]></title>
    <url>%2F2018%2F02%2F21%2Fmongo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[学习mongoDB的修改(update)操作。 昨晚跟朋友出去浪了，没有继续学习，只能今天学习然后更下博客啦。 今天照着技术胖的博客继续学习了mongoDB的更新操作。 首先先把例子前提搭好：12345678910111213141516 var workmate =&#123; name:'Mike', age:20, sex:1, job:'UI设计', skill:&#123; skillOne:'PhotoShop', SkillTwo:'UI', SkillThree:'Word+Excel+PPT' &#125;, regeditTime:new Date()&#125;var db = connect('company');//创建company数据库db.workmate.insert(workmate);//新建workmate集合 $set修改器用来修改一个指定的键值(key)。1db.workmate.update(&#123;name: "Mike"&#125;, &#123;$set:&#123;age:22&#125;&#125;); 而对于文档内嵌文档的修改方式。使用点操作符 1db.workmate.update(&#123;name: "Mike"&#125;, &#123;$set: &#123;"skill.SkillThree": "word"&#125;&#125;); $unset修改器用于删除指定的key 1db.workmate.update(&#123;name: "Mike"&#125;, &#123;$unset: &#123;age: ''&#125;&#125;); $inc修改器对数据进行修改 12db.workmate.update(&#123;name: "Mike"&#125;, &#123;$inc: &#123;age: -2&#125;&#125;);//直接减2得到想要的数字。这里想要得到18，而原本是20 multi为所有的数据都添加上一个字段。设置multi为true，否则只为第一个数据增加了字段 1db.workmate.update(&#123;&#125;, &#123;$set: &#123;interest: []&#125;&#125;, &#123;multi: true&#125;); 此时所有数据都添加上了interest这个字段。 upsert当需要新增数据时，upsert在找不到值的情况下，可以直接插入这条数据。设置upsert为true 1db.workmate.update(&#123;name: "John"&#125;, &#123;$set: &#123;age: 20&#125;&#125;, &#123;upsert: true&#125;); 运行结果显示，新增了John这一行数据。 $push用于操作数组 12db.workmate.update(&#123;name: "John"&#125;, &#123;$push: &#123;interest: 'draw'&#125;&#125;);//为interest数组新增了'draw'的元素 $ne$ne主要的作用是，检查一个值是否存在，如果不存在再执行操作，存在就不执行。 12db.workmate.update(&#123; name: "John", interest: &#123; $ne: "playGame" &#125; &#125;, &#123; $push: &#123; interest: "Game" &#125; &#125;);//如果interest中有playGame，则不添加Game。否则添加 $addToSet查找是否存在，不存在就push上去。相比$ne更容易理解。 12db.workmate.update(&#123; name: "John" &#125;, &#123; $addToSet: &#123; interest: "readBook" &#125; &#125;)//interest数组中不存在'readBook'，则将'readBook'添加上 $each修改器它可以传入一个数组，一次增加多个值进去。 12var newInterset = ["Sing", "Dance", "Code"];db.workmate.update(&#123; name: "John" &#125;, &#123; $addToSet: &#123; interest: &#123; $each: newInterset &#125; &#125; &#125;) $pop用于删除数组值。 $pop只删除一次，并不是删除所有数组中的值。而且它有两个选项，一个是1和-1。 1：从数组尾部进行删除 -1：从数组头部进行删除 1db.workmate.update(&#123; name: 'John' &#125;, &#123; $pop: &#123; interest: 1 &#125; &#125;) 接下来看一点高级的12db.workmate.update(&#123;sex: 1&#125;, &#123;$set: &#123;money: 1000&#125;&#125;, false, true);//上面一句等同于这一句：db.workmate.update(&#123;sex: 1&#125;, &#123;$set: &#123;money: 1000&#125;&#125;, &#123;upsert: false&#125;, &#123;multi: true&#125;); 与之有异曲同工之妙的如下语句 123456789var myModify = &#123; findAndModify: 'workmate',//需要查找或修改的集合 query: 'Mike',//指定哪条数据 update: &#123;$set: &#123;age: 29&#125;&#125;,//进行修改 new: true //返回更新前的文档(false)还是更新后的文档(true)&#125;var resultMessage = db.runCommand(myModify);//使用runCommand来执行语句printjson(resultMessage);//以json形式打印结果 runCommand可以执行数据库操作的语句 两者都是执行更新操作，但是后者的安全性能相对较高，更加值得学习。]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mongo学习笔记(一)]]></title>
    <url>%2F2018%2F02%2F20%2Fmongo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[开始学习mongoDB。 MongoDB简介 MongoDB是一个基于分布式文件存储的数据库，由C++语言编写。目的是为WEB应用提供扩展的高性能的数据存储解决方案。MongoDB是一个介于关系型数据库和非关系型数据库之间的产品，是非关系型数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。 开始安装MongoDB安装步骤： 去官网下载MongoDB，https://www.mongodb.com/，在网站中找到Download按钮进行下载。 下载后进行安装，默认配置一直安装下去就可以了。 安装完成后，需要配置“环境变量”，目的是再命令行中直接使用，而不需要输入很长的路径。 运行MongoDB服务端安装好MongoDB数据库后，我们需要启用服务端才能使用。启用服务的命令是mongod。打开命令行，执行mongod。在命令中直接输入mongod，但是你会发现服务并没有启动，报了一个exception，服务停止了。这是因为我们需要在安装盘的根目录，建立data/db,这两个mongodb需要文件夹。新建所需文件夹之后再次运行mongod，这时候服务就可以开启了，链接默认端口是27017。 链接MongoDB服务端开启MongoDB服务器之后，我们需要进行链接。命令行操作为mongo。 一些常用的mongo基本命令我们都知道关系型的数据库，如mysql，oracle等都是采用SQL语句进行数据库增删查改的。而非关系型数据库中的佼佼者MongoDB则采用前端人员熟知的JavaScript语言进行数据库操作。可以来一段代码看看： 1234function tobee() &#123; return "welcome to tobee's blog";&#125;print(tobee()); //使用print进行打印而不能再使用console.log 一些基础命令show dbs —— 查看存在的数据库。原始存在admin和local两个数据库db.version() —— 查看数据库版本db —— 显示当前使用的数据库的名称use XXX —— 切换至某个数据库（若没有，则新建）show collection —— 查看数据库的集合db.集合.insert() —— 新建数据集合和插入文件。如db.user.insert({&quot;name&quot;:&quot;tobee&quot;})db.集合.find() —— 查询所有数据db.集合.update({查询条件}，{修改条件}) —— 修改文件数据db.集合.remove(条件) —— 删除文件数据。如db.user.remove({&quot;name&quot;:&quot;tobee&quot;}) 用js文件写mongo命令我们如果在命令行对我们数据库中的文件增删查改的话，会发现操作起来十分麻烦。这时候我们可以将需要操作的命令全部写在一个js文件中，再用mongo命令执行就可以了。 新建test.js，在其中新建一个数据库 1var db = connect("user"); //有则连接，没有则创建 终端执行命令 1mongo test.js 此时js文件中的mongo命令会被执行。 今天下午就先学这些，巩固下。晚上再继续学继续更新。对了，我是在技术胖的博客上学习的，超棒，推荐给大家。http://jspang.com/2017/12/16/mongdb/]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[重拾git]]></title>
    <url>%2F2018%2F02%2F20%2F%E9%87%8D%E6%8B%BEgit%2F</url>
    <content type="text"><![CDATA[来聊聊git。从我接触git开始算起应该是有半年多的时间了，那时候需要帮学校朋友的一个小项目写一个移动端网页然后让大家可以访问，后来了解到GitHub page就可以做到无需购买域名和服务器就可以帮我们托管自己的网站。所以我开始学习git然后现在重新回想下记录下来。 git Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds(Linux的发明者) 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 一步一步来 先登录GitHub，手动创建新仓库，并复制新的git地址 首先在目的目录下，右键进入git bash 然后git init初始化，让文件夹变成git可管理的仓库git add文件名 ：将指定文件上传至暂存区git commit -m 相关信息 ：将暂存区内容提交到主分支上此时若是第一次使用git上传文件，会提示进行相关内容的配置git config --global user.email &quot;your @example.com&quot;git config --global user.name &quot;your name&quot;git remote rm origingit remote add origin &quot;git地址&quot;：将分支与远程仓库地址进行关联git push -u origin master ：将本地仓库文件提交到远程仓库 此时若发现没有权限，需要公钥 ssh-keygen -t rsa -C &quot;邮箱&quot; (一路回车) 在GitHub的setting界面左边点选SSH and GPG keys，右上角选News SSH key 打开c:/user/administer/.ssh/目录(因人而异哦)，打开id_rsa.pub文件，将其复制到GitHub的key中，title任意输入此时可以开始提交文件至远程仓库，即git push -u origin master git clone git地址 ：git克隆项目 一些错误解决方法 提示出错信息：fatal: remote origin already exists输入git remote rm origin，再输入git remote add origin &quot;git地址&quot;。或者直接push 当远程仓库有一些本地文件没有的文件时，也会报错。此时先全部pull下来，再重新push上去 更多的git教程可参考廖雪峰的官方教程→Git教程]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[杂想]]></title>
    <url>%2F2018%2F02%2F19%2F%E6%9D%82%E6%83%B3%2F</url>
    <content type="text"><![CDATA[大年初四。just try it今天花了一个下午还有晚上的时间利用hexo和GitHub page搭建了属于自己的博客并对其做了个性化的DIY，同时也进行了前两篇博客的撰写，之后可能要买个域名将其解析到GitHub page上。接下来，我会将以前在没有博客的时候总结的一些学习上的坑都用博客的方式重新记录下来，勉励自己，同时也希望帮到别人，哪怕一个人。而且接下来的学习生涯也会在博客上留下我的足迹。 祝大家新年快乐。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[对hexo中Next主题的DIY]]></title>
    <url>%2F2018%2F02%2F19%2F%E5%AF%B9hexo%E4%B8%ADNext%E4%B8%BB%E9%A2%98%E7%9A%84DIY%2F</url>
    <content type="text"><![CDATA[总要有点追求，年轻人。在搭建好了自己的博客之后，发现网上有很多大神都自己DIY了这个Next主题。于是我翻阅了好几篇文章还有Hexo和Next的官方文档之后，开始着手进行这个主题的DIY。 文章主页添加阴影打开\themes\next\source\css\_custom\custom.styl，向里面加入： 1234567.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 在右上角或者左上角实现fork me on github→字母版→图案版挑选自己喜欢的样式，并复制代码。然后粘贴刚才复制的代码到themes/next/layout/_layout.swig文件中(放在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;的下面)，并把href改为你的github地址。 添加动态背景如果next主题在5.1.1以上的话就可以简单点设置，直接在主题配置文件_config.yml中找到canvas_nest: false或者three_waves:false，把它相应改为true就行了（注意分号后面要加一个空格）。 实现点击界面出现桃心效果在网址输入如下http://7u2ss1.com1.z0.glb.clouddn.com/love.js然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。将love.js文件放到路径/themes/next/source/js/src里面，然后打开\themes\next\layout\_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码：12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 在网站底部加上访问量打开主题配置文件\themes\next\_config.yml，在其中找到busuanzi_count，将参数enable改为true。接着在文件\themes\next\layout\_partials\footer.swig中的合适位置上加上如下参考代码，12345&lt;div class="powered-by"&gt;&lt;i class="fa fa-user-md"&gt;&lt;/i&gt;&lt;span id="busuanzi_container_site_uv"&gt; 本站访客数:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 网站底部字数统计在命令行使用npm安装hexo-wordcount1npm install hexo-wordcount --save 然后在/themes/next/layout/_partials/footer.swig文件尾部加上：1234&lt;div class="theme-info"&gt; &lt;div class="powered-by"&gt;&lt;/div&gt; &lt;span class="post-count"&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 实现统计功能在命令行使用npm安装hexo-wordcount1npm install hexo-wordcount --save 然后在主题的配置文件_config.yml中，配置如下： # Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true 参考来源（感谢~）http://blog.csdn.net/qq_33699981/article/details/72716951http://www.cduyzh.com/hexo-settings-4/]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[遇见hexo]]></title>
    <url>%2F2018%2F02%2F19%2F%E9%81%87%E8%A7%81hexo%2F</url>
    <content type="text"><![CDATA[一篇水水的技术分享。大佬勿喷大概很久之前就想拥有属于自己的博客了，自己是想完全靠自己搭建一个包括网站源代码，域名服务器购买，网站备案都由自己搞定，但是总是没时间后来就忘记了。之后听说Hexo可以帮我们搭建属于自己的博客而且也没有其他现有博客那么多限制，可以自己DIY。于是我就跟着hexo官方文档还有Next主题的官方文档一步一步搭建起现在的这个博客。接下来分享一些搭建时候的心路历程。 HEXO Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。这里我选用的是GitHub。如果想要更加全面的了解Hexo，可以到其官网了解更多的细节。 下载node，git在下载git的过程中不要点击“仅仅使用git bash”，点击“与Windows命令行结合”，本人遇到的坑就在这里，使用命令行输入稍后将要输入的命令hexo d进行部署的时候报了错，需要在git bash输入这句语句才有效。 GitHub page的配置去到GitHub新增一个仓库，名字跟用户名一样，如“yourname.github.io”。 用SSH keys关联Hexo与Github Pages在git bash中输入语句ssh-keygen -t rsa -C &quot;注册Git的邮箱地址&quot;。接着会生成一个密钥，去到存放这个密钥的文件夹中找到id_rsa.pub，如“C:\Users\Administrator.ssh”，将其中内容复制粘贴到https://github.com/settings/ssh 的 new SSH key中。接着输入ssh -T git@github.com查看是否设置成功。 新建文件夹放置博客内容在命令行使用npm安装hexo，步骤如下：12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 此时在浏览器中打开http://localhost:4000/ 就可以浏览博客了。 配置Deployment在_config.yml文件中，找到Deployment，然后按照如下修改： # Deployment## Docs:https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 本地文件提交到Git Pages12345678910// 删除旧的 public 文件hexo clean// 生成新的 public 文件hexo generate或者hexo g// 开始部署hexo deploye或者hexo d 需要安装一个扩展 npm install hexo-deployer-git --save然后在浏览器中输入 https:/yourname.github.io （用户名改成你的）看到了 Hexo 与 GitHub Pages 已经成功关联了。至此博客就算搞定啦~ 致谢即将成为史上最具用户体验的Hexo+GitHub Pages搭建博客的教程]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
</search>
