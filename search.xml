<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue组件通信模式]]></title>
    <url>%2F2018%2F03%2F22%2FVue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前几天百度电面了我，问了一些vue框架的相关知识。可惜，学的太不全面了，有一些是问倒了我。组件间通信我重新学习了下，进行一个总结。（可能还不是很完善- -） Vue组件通信模式属性和事件属性属性允许你传递任意的数据类型到一个子组件中，并且允许你控制组件接收何种类型的数据。属性的更新也是响应式的，这使得无论任何时候，父组件的数据改变，子组件就会更新。以下是父组件传值到子组件的例子： HTML代码： 1234&lt;div id="exp1"&gt; &lt;input v-model="parentmsg"&gt;&#123;&#123;parentmsg&#125;&#125;&lt;/input&gt; &lt;child :childmsg="parentmsg"&gt;&lt;/child&gt;&lt;/div&gt; JS代码： 123456789101112Vue.component('child', &#123; template:`&lt;p&gt;&#123;&#123;childmsg&#125;&#125;&lt;/p&gt;`, props: ['childmsg']&#125;)let vm1 = new Vue(&#123; el: "#exp1", data()&#123; return &#123; parentmsg: '1111' &#125; &#125;&#125;) 事件事件提供了一种子组件通知父组件做出改变的方式。以下是子组件传值到父组件的例子： HTML代码： 1234&lt;div id="exp2"&gt; &lt;p v-for="msg in parentMsg"&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;child-button @message="handleParentMsg"&gt;&lt;/child-button&gt;&lt;/div&gt; JS代码： 1234567891011121314151617181920212223242526272829303132Vue.component('child-button', &#123; template: ` &lt;div&gt; &lt;input v-model="childmsg" /&gt; &lt;button @click="handleChildMsg"&gt;Send&lt;/button&gt; &lt;/div&gt; `, data() &#123; return &#123; childmsg: '1234' &#125; &#125;, methods: &#123; handleChildMsg: function () &#123; this.$emit('message', &#123; message: this.childmsg &#125;); &#125; &#125;&#125;)let vm2 = new Vue(&#123; el: "#exp2", data() &#123; return &#123; parentMsg: [] &#125; &#125;, methods: &#123; handleParentMsg: function (payLoad) &#123; this.parentMsg.push(payLoad.message); &#125; &#125;&#125;) 事件总线创建一个全局事件总线来在任意位置传递事件。可用于非父子组件间的通信。参照此文章。先创建一个空的Vue实例作为总线。总线可单独放置在一个js文件独立开来。如event-bus.js: 12import Vue from 'vue’;export const EventBus = new Vue(); 创建PleaseClickMe.vue: 123456789101112131415161718192021222324&lt;template&gt; &lt;div class="pleeease-click-me" @click="emitGlobalClickEvent()"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 导入创建的event-bus.jsimport &#123; EventBus &#125; from './event-bus.js';export default &#123; data() &#123; return &#123; clickCount: 0 &#125; &#125;, methods: &#123; emitGlobalClickEvent() &#123; this.clickCount++; // 点击触发事件并传递载荷(the clickCount) EventBus.$emit('i-got-clicked', this.clickCount); &#125; &#125;&#125;&lt;/script&gt; 再创建receive.vue: 123456import &#123; EventBus &#125; from './event-bus.js';// 监听i-got-clicked事件和接收传递过来的载荷EventBus.$on('i-got-clicked', clickCount =&gt; &#123; console.log(`Oh, that's nice. It's gotten $&#123;clickCount&#125; clicks!`)&#125;); Provide / Injectprovide/inject机制是Vue一个比较新的特性。它可以选择性的暴露祖先组件的数据或者方法到其所有的后代中。provide 选项应该是一个对象或返回一个对象的函数。inject 选项应该是一个字符串数组，或一个对象。 这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。 官方示例： 12345678910111213141516//父组件var Provider = &#123; provide: &#123; foo: 'bar' &#125;, // ...&#125;//子组件var Child = &#123; inject: ['foo'], created () &#123; console.log(this.foo) // =&gt; "bar" &#125; // ...&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[sass学习日记]]></title>
    <url>%2F2018%2F03%2F10%2Fsass%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[学习css预编译器sass。 CSS预处理器有好几种，less，sass，stylus等等。它们的优点是：语言级逻辑处理，有动态特性，可以改善项目结构。它们的基本思想是，用一种专门的编程语言，进行网页样式设计，然后再编译成正常的CSS文件。所以今天选择其中的一种sass来学习，其实其他的本质上没有太大区别。 sass安装因为sass依赖于ruby环境，所以装sass之前先确认装了ruby。可以先去官网下载ruby（http://rubyinstaller.org/downloads）。在安装的时候，勾选Add Ruby executables to your PATH这个选项，添加环境变量，不然以后使用编译软件的时候会提示找不到ruby环境。 安装完Ruby之后，在刚才我们安装的ruby中，打开Start Command Prompt with Ruby，然后输入下列命令行进行安装sass操作： 1gem install sass 查看是否安装成功： 1sass -v 然后就可以使用了。 使用sass网上教程有使用命令行的，我自己选择使用图形界面来进行操作，比较直观明了。下载Koala（http://koala-app.com/index-zh.html）。 koala是一个前端预处理器语言图形编译工具，支持Less、Sass、Compass、CoffeeScript，帮助web开发者更高效地使用它们进行开发。跨平台运行，完美兼容windows、linux、mac。 每次做项目的时候，新建style文件夹，其中放置各种scss文件。然后最后将style文件夹通过Koala编译成许多普通的css文件然后集成到一个css上（如index.css）。接着在页面引入这个index.css就可以了。（按照我的理解进行的表述 - -） 基本用法变量SASS允许使用变量，所有变量以$开头。 1234$blue : #1875e7; div &#123; color : $blue;&#125; 如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。 1234$side : left;.rounded &#123; border-#&#123;$side&#125;-radius: 5px;&#125;//结果：border-left-ridius 计算功能SASS允许在代码中使用算式。 12345body &#123; margin: (14px/2); top: 50px + 100px; right: $var * 10%;&#125; 嵌套SASS允许选择器嵌套。这一点对我们编写样式是十分直观明了的。 123div h1 &#123; color : red;&#125; 可以写成： 12345div &#123; h1 &#123; color:red; &#125;&#125; 属性也可以嵌套，比如border-color属性，可以写成： 12345p &#123; border: &#123; color: red; &#125;&#125; 注意，border后面必须加上冒号。在嵌套的代码块内，可以使用&amp;引用父元素。比如a:hover伪类，可以写成： 123a &#123; &amp;:hover &#123; color: #ffb3ff; &#125;&#125; 注释SASS共有两种注释风格。 标准的CSS注释 / comment / ，会保留到编译后的文件。单行注释 // comment，只保留在SASS源文件中，编译后被省略。在/后面加一个感叹号，表示这是”重要注释”。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。 /! 重要注释！ */ 代码的重用继承SASS允许一个选择器，继承另一个选择器。比如，现有class1： 123.class1 &#123; border: 1px solid #ddd;&#125; class2要继承class1，就要使用@extend命令： 1234.class2 &#123; @extend .class1; font-size:120%;&#125; MixinMixin有点像C语言的宏（macro），是可以重用的代码块。使用@mixin命令，定义一个代码块。 1234@mixin left &#123; float: left; margin-left: 10px;&#125; 使用@include命令，调用这个mixin。 123div &#123; @include left;&#125; mixin的强大之处，在于可以指定参数和缺省值。 1234@mixin left($value: 10px) &#123; float: left; margin-right: $value;&#125; 使用的时候，根据需要加入参数： 123div &#123; @include left(20px);&#125; 下面是一个mixin的实例，用来生成浏览器前缀。 12345@mixin rounded($vert, $horz, $radius: 10px) &#123; border-#&#123;$vert&#125;-#&#123;$horz&#125;-radius: $radius; -moz-border-radius-#&#123;$vert&#125;#&#123;$horz&#125;: $radius; -webkit-border-#&#123;$vert&#125;-#&#123;$horz&#125;-radius: $radius;&#125; 使用的时候，可以像下面这样调用： 12#navbar li &#123; @include rounded(top, left); &#125;#footer &#123; @include rounded(top, left, 5px); &#125; 颜色函数SASS提供了一些内置的颜色函数，以便生成系列颜色。 1234lighten(#cc3, 10%) // #d6d65cdarken(#cc3, 10%) // #a3a329grayscale(#cc3) // #808080complement(#cc3) // #33c 插入文件@import命令，用来插入外部文件。 1@import "path/filename.scss"; 如果插入的是.css文件，则等同于css的import命令。 1@import "foo.css"; 高级用法自定义函数SASS允许用户编写自己的函数。 123456@function double($n) &#123; @return $n * 2;&#125;#sidebar &#123; width: double(5px);&#125; 这也是很方便的一点。当时在做vue仿饿了么的时候就用到了stylus中相同的特性，通过传递不同参数，生成不同样式，进而使得代码量不冗余。]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[读《三体》有感]]></title>
    <url>%2F2018%2F03%2F09%2F%E8%AF%BB%E3%80%8A%E4%B8%89%E4%BD%93%E3%80%8B%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[《三体》是中国大陆作家刘慈欣于2006年5月至12月在《科幻世界》杂志上连载的一部长篇科幻小说，出版后成为中国大陆最畅销的科幻长篇小说之一[1]。2008年，该书的单行本由重庆出版社出版。本书是三体系列（系列原名为：地球往事三部曲）的第一部，该系列的第二部《三体II：黑暗森林》已经于2008年5月出版。2010年11月，第三部《三体III：死神永生》出版发行。 2011年，“地球往事三部曲”在台湾陆续出版。小说的英文版获得美国科幻奇幻作家协会2014年度“星云奖”提名[2]，并荣获2015年雨果奖最佳小说奖。 这是维基百科 对《三体》及其作者的基本介绍。 半个月前，心血来潮开始看《三体》。总计花了近24个小时，终于看完这部科幻著作。小说分为三章，分别是《三体》、《三体Ⅱ·黑暗森林》、《三体Ⅲ·死神永生》。国内科幻小说能到达这样一个程度实属可贵，故事很长但是没有冗余之处，一环扣一环，而且总能在适当之处通过紧张的环节或是描写来刺激读者的神经。故事主线从现代开始，然后通过人物与情节不断发展，慢慢展现了这部小说的灵魂。从文化大革命再到神奇的三体世界，从一颗渺小的质子再到无限的宇宙，这部小说带给读者的不只是物理定律和知识的美妙，同时也为我们奉上想象力不能触及的宇宙世界万物这饕餮大餐。书中人物栩栩如生，在我脑海中挥散不去，像是救世主“罗辑”自己捏造出来的情人一般，虽然虚假，但也被赋予了生命。小说建立在大量现有基础科学水平上的无限遐想与延伸，时间线不停变化于古今中外。个人觉得第二部黑暗森林最为出彩。“黑暗森林”法则，实在精妙，“毁灭一个文明比观测一个文明容易得多”，地球就像在篝火旁的小孩子，对着四周的黑暗大喊“我在这里”，于是，灭顶之灾。小说最终以太阳系银河系乃至宇宙覆灭为结局，最后看完只有震撼和对作者脑洞的佩服。文笔不好，只能写这么多，对于这样一部好书，我不想读完就完，可以留下点什么呢，就是一篇用心写的读后感了。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mongo学习笔记（四）]]></title>
    <url>%2F2018%2F03%2F07%2Fmongo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[学习mongoDB的索引和管理。 今天学习了MongoDB的索引操作还有对数据库的管理。 索引无论是在关系型数据库还是文档数据库，建立索引都是非常重要的。不过建立索引是要消耗硬盘和内存资源的，所以要根据程序需要进行建立。MongoDB也给我们进行了限制，只允许我们建立64个索引值。 建立索引建立索引只需要一句话1db.集合.ensureIndex(&#123;字段:1&#125;) //字段为1表明为其建立索引 查看索引1db.集合.getIndexes() 全文索引有些时候需要在大篇幅的文章中搜索关键词，这时候想搜索关键字是非常不容易的，索引MongoDB为我们提供了全文索引。 先在info集合中插入两条数据 12db.info.insert(&#123;contentText:"I am a slow walker,but I never walk backwards."&#125;)db.info.insert(&#123;contentText:"Your happy passer-by all knows, my distressed there is no place hides."&#125;) 接着为其创建全文索引 12db.info.ensureIndex(&#123;contentText:"text"&#125;)//使用"text"表示使用全文索引 创建完成之后就可以使用索引进行内容查找了，如 1db.info.find(&#123;$text:&#123;$search:"slow"&#125;&#125;) 其中$text则代表使用全文索引进行查找，$search为需要查找的内容。如果想要同时进行多个关键词的查找，则可以在$search中加入新关键词同时以空格符隔开。如 1db.info.find(&#123;$text:&#123;$search:"slow hides"&#125;&#125;) 还可以使用减号“-”来取消某个关键词 1db.info.find(&#123;$text:&#123;$search:"slow -hides"&#125;&#125;) 全文搜索中是支持转义符的，比如我们想搜索的是两个词walk backwards和hides，这时候需要使用\斜杠来转义。 1db.info.find(&#123;$text:&#123;$search:"\"walk backwards\" hides"&#125;&#125;) 管理用户的创建与修改 安装好MongoDB时，它为我们默认开了一个最高管理权限方便我们管理数据库，我们可以用mongo链接数据库，就是这个原理。但在实际开发中并一般不能使用这个用户，因为大家都知道和最高权限的原因，安全性和可靠性都不适合，所以要对MongoDB的用户进行管理。 因此，MongoDB为我们提供了“建权”操作，即建立权限。 首先执行以下mongo命令 1use admin 我们可以自己创建一个新用户而不是使用mongo。 123456789101112131415db.createUser(&#123; user: 'tobee', pwd: '123456', customData: &#123; name: 'tobee', age: 18 &#125;, roles: [ &#123; role: 'readWrite', db: 'company' &#125;, 'read' ]&#125;) roles为权限设定。此处除了company数据库的权限单独设置为读写readWrite外，其余对全部数据库设为只读read。新建完成之后，我们看一下该用户是否创建成功。使用以下命令行 1db.system.users.find() 接着断开MongoDB服务器，以建权方式重新打开服务器1mongod --auth 此时就不能直接使用mongo连接数据库了。而是需要用户名和密码登录。 1mongo -u tobee -p 123456 127.0.0.1:17027/admin -u选项为用户名，-p为密码，之后的为电脑IP和MongoDB占用的端口号(17027)和所需进入的数据库(admin)。此时便可以使用自己的其他用户名与远程mongo服务器进行链接了。以下代码可以验证用户名与密码是否一致。 12db.auth("tobee","123456")//如果正确返回1，如果错误返回0。（Error：Authentication failed。） 备份和还原MongoDB的备份：mongodump。以下都是该命令的参数12345678mongodump --host 127.0.0.1 --port 27017 --out D:/databack/backup --collection myCollections --db test --username username --password password --host为IP地址，--port为端口号，--out可将备份保存到D:/databack/backup目录下。 比如现在我们备份所有MongoDB里的库到D盘的databack文件夹下，就可以把命令写成这样 1mongodump --host 127.0.0.1 --port 27017 --out D:/databack/ MongoDB的恢复：mongostore。以下都是该命令的参数 123456mongorestore --host 127.0.0.1 --port 27017 --username username --password password &lt;path to the backup&gt; &lt;path to the backup&gt;为当时保存备份的目录。 当某个已备份的集合不小心删除之后，可以使用还原语句恢复。 1mongorestore --host 127.0.0.1 --port 27017 D:/databack/ 毕竟没有实际项目可以练练手，所以我也只能多看些教程和敲敲基本的代码了。keep learning~]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vuex学习日记]]></title>
    <url>%2F2018%2F03%2F05%2FVuex%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[学习vue全家桶中的状态管理工具 —— Vuex 挺久之前就开始学习vue了，vue全家桶中的vuex也有稍微了解，但是那个时候还没有对其进行更熟悉的了解吧，今天就重新认真学习了下。 看看官方对Vuex的解释， Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 在学习之后，个人对其也有了自己的理解，我觉得可以理解为在data中的属性需要共享给其他vue组件使用的部分。简单的说就是data中需要共用的属性。比如做一个购物车，那么购物车的内容就需要在不同页面中进行保留和传递，这时候就可以使用Vuex对其进行集中管理。在此之前，我们都是用父子组件互相传值来完成的。 在官方文档中，会学到 Vue 的一些核心概念，深入理解所有的概念对于使用 Vuex 来说是必要的。接下来我自己通过一个小案例来弄清楚这些核心概念，当做一个总结了。 起步第一步先通过vue-cli脚手架工具搭建起vue项目运行的环境，这里就不多说了。接着通过npm安装vuex。本人用的是VScode，所以自带了终端，直接ctrl+`打开终端，输入下面命令行： 1npm install vuex --save vuex在开发过程需要用到，所以必须加上--save选项。 接着新建store.js文件，将vue和vuex导入，并且使用vuex。 1234import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex); 接着创建一个仓库state（我自己的理解 - -），再放入一个变量count。（做一个小计数器） 1234//state理解为存放共享状态的仓库const state = &#123; count: 1&#125; 然后将内容导出： 123export default new Vuex.Store(&#123; state&#125;) state在component文件夹下创建Count.vue模板文件。 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt;&lt;hr/&gt; &lt;h3&gt;&#123;&#123;$store.state.count&#125;&#125; --- &#123;&#123;count&#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import store from &apos;../vuex/store.js&apos;; //解构赋值得到mapState import &#123; mapState &#125; from &apos;vuex&apos;; export default &#123; data() &#123; return &#123; msg: &apos;Hello Vuex&apos; &#125; &#125;, //利用mapState方法可以简化拼写，如$store.state.count简化为count //最容易理解的写法为： // computed: &#123; // count() &#123; // return this.$store.state.count; // &#125; // &#125;, computed: &#123; ...mapState([&apos;count&apos;]) &#125;, store &#125;&lt;/script&gt;&lt;style lang=&quot;&quot;&gt; &lt;/style&gt; 一开始就需要引入并注册store，这点很重要。其中利用mapState辅助函数帮助我们生成计算属性。如上HTML代码中的$store.state.count可以通过mapState直接简化为count。只需从vuex中解构赋值得到mapState，再在computed中做映射。由于mapState 函数返回的是一个对象，所以可以通过ES6新增的对象展开运算符...将它与局部计算属性混合使用。 mutations接下来为计数器增加两个按钮，一加一减。Count.vue中的HTML代码如下： 123456789101112&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt;&lt;hr/&gt; &lt;h3&gt;&#123;&#123;$store.state.count&#125;&#125; --- &#123;&#123;count&#125;&#125;&lt;/h3&gt; &lt;!--新增--&gt; &lt;p&gt; &lt;button @click=&quot;$store.commit(&apos;add&apos;,5)&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;$store.commit(&apos;reduce&apos;)&quot;&gt;-&lt;/button&gt; &lt;/p&gt; &lt;!--新增--&gt; &lt;/div&gt;&lt;/template&gt; 上面增加了两个方法add和reduce，接下来在store.js中分别实现： 123456789//mutations用于改变state中的状态值const mutations = &#123; add(state, n) &#123; state.count += n; &#125;,//可传第二个参数 reduce(state) &#123; state.count-- &#125;,&#125; 可以看到，这里使用mutations。更改 Vuex 的 store 中的状态的唯一方法是提交 mutation，即上面可见的，需要调用$store.commit()方法。参数则为函数。同时也要像前面state一样，导出mutations。 如果我们希望直接通过@click=&#39;add()&#39;这样就可以直接调用方法，而不需要利用$store.commit()时，我们可以使用mapMutations。在Count.vue中，同理先从vuex中解构赋值得到mapMutations，然后在methods中进行方法的映射： 12//将this.add()和this.reduce()分别映射为this.$store.commit('add')和this.$store.commit('reduce') methods: mapMutations(['add', 'reduce']), 此时，在Count.vue中我们便可以直接调用函数，跟没引用vuex插件一样。 12&lt;button @click="add"&gt;+&lt;/button&gt;&lt;button @click="reduce"&gt;-&lt;/button&gt; getters接着是getters。getters从表面是获得的意思，可以把他看作在获取数据之前进行的一种再编辑,相当于对数据的一个过滤和加工。你可以把它看作store.js的计算属性。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 在store.js做如下操作： 123456//getters用于计算过滤const getters = &#123; count: (state) =&gt; &#123; return state.count += 100; &#125;&#125; 同时导出getters。接着先从vuex中解构赋值得到mapGetters，然后computed中，同理使用扩展运算符： 123computed: &#123; ...mapGetters(['count'])&#125; 此时跟普通Vue实例中的computed一样，当需要被计算的值发送变化时，计算属性先做出变化，改变当前的值。 在学习的过程中还有两个概念——action和module。 action : actions和之前讲的mutations功能基本一样，不同点是，actions是异步的改变state状态，而mutations是同步改变状态。 module : 状态管理器的模块组操作。随着项目的复杂性增加，我们共享的状态越来越多，这时候我们就需要把我们状态的各种操作进行一个分组，分组后再进行按组编写。 这里有空的话会再去看官方文档或者技术胖的博客，进行一个更系统的学习。]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于学习微信小程序的一些记录]]></title>
    <url>%2F2018%2F03%2F02%2F%E5%85%B3%E4%BA%8E%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[关于微信小程序自己的一些学习历程记录一下吧。 上个学期，经过一个朋友介绍，我有幸参加了学校“挑战杯”其中一个小组的项目，负责该项目的微信小程序部分。那时候我一点都不了解小程序，通过自己慢慢学习摸索，帮助该团队完成了这个项目1.0版本的小程序端后，退出该项目团队。接下来就我个人的学习经历什么的随便写写，算是一种记录。该项目是制作一个健身器材。就我个人而言，我知道健身有在健身房进行大汗淋漓的健身，也有在体侧房进行测量性质之类的健身，我们的项目就是属于后者，制作一个能测量出被测量者的各方面力量。当时硬件方面已经成熟，上位机就绪，可以在机器上进行实验。后台小组以及我负责的小程序都是后来加入的。说回小程序，此处应有图，不过这个项目将来要上市的（团队负责人很有生意头脑），所以意思意思就好。以下的图是在小程序开发助手和web开发者工具看的。 关于登录来说说小程序的登录。引用小程序官方文档的登录时序图，整个登录流程基本如下图所示：该图中，小程序指的就是我们使用小程序框架写的代码部分，第三方服务器一般就是我们自己的后台服务程序，微信服务器是微信官方的API服务器。 在客户端获取当前登录微信用户的登录凭证(code)我们可以使用wx.login()方法得到一个登录凭证，获取该凭证是小程序登录的第一步。 接着可以在小程序的App代码中发起登录凭证请求，也可以在其他任何Page页面代码中发起登录凭证请求。 1234567891011121314App(&#123; onLaunch: function() &#123; wx.login(&#123; success: function(res) &#123; var code = res.code; if (code) &#123; console.log('获取用户登录凭证：' + code); &#125; else &#123; console.log('获取用户登录态失败：' + res.errMsg); &#125; &#125; &#125;); &#125;&#125;) 获取唯一标识(openid)和会话密钥(session_key)使用wx.request()方法，请求后台的API，并将登录凭证(code)传递过去。例如在我们前面代码的基础上增加： 12345678910111213141516171819202122App(&#123; onLaunch: function() &#123; wx.login(&#123; success: function(res) &#123; var code = res.code; if (code) &#123; console.log('获取用户登录凭证：' + code);// --------- 发送凭证 ------------------ wx.request(&#123; url: 'https://www.yourAPI.com/user', data: &#123; code: code &#125; &#125;)// ------------------------------------ &#125; else &#123; console.log('获取用户登录态失败：' + res.errMsg); &#125; &#125; &#125;); &#125;&#125;) 你的后台服务(/user)接着需要使用这个传递过来的登录凭证，去调用微信接口换取openid和session_key，接口地址格式如下所示： 1https://api.weixin.qq.com/sns/jscode2session?`appid=APPID`&amp;`secret=SECRET`&amp;`js_code=JSCODE`&amp;grant_type=authorization_code 其中APPID和SECRET则是申请小程序时候就给出的，可以去小程序后台管理界面查看，JSCODE则是小程序端传递过来的登录凭证code。 后台代码这里不是我负责，所以没有贴出。不过其实大同小异。 你自己的后台代码如果成功执行的话，就可以得到openid和session_key。这个信息就是当前微信账户在微信服务器那边的登录态了。至此登录部分就完成了。 其他之后就是一些图片上传啊，UI的设计啥的，这些去微信小程序官方文档都能找得到。UI则采用了WeUI（https://weui.io/）。小程序也采用了数据驱动的方式操作文档，这是很棒的，跟现有的流行框架，如VUE，Angular一样，同时也支持ES6语法。 总之，这个项目让我体验到前后台合作开发的流程，算是有收获。继续学习下去吧。]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mongo学习笔记（三）]]></title>
    <url>%2F2018%2F02%2F23%2Fmongo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[学习mongoDB的查询(find)操作。 今天照着技术胖的博客继续学习了mongoDB的查询操作。 首先先把例子前提搭好：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130 var workmate1 = &#123; name: 'JSPang', age: 33, sex: 1, job: '前端', skill: &#123; skillOne: 'HTML+CSS', skillTwo: 'JavaScript', skillThree: 'PHP' &#125;, regeditTime: new Date(), interest: []&#125;var workmate2 = &#123; name: 'ShengLei', age: 31, sex: 1, job: 'JAVA后端', skill: &#123; skillOne: 'HTML+CSS', skillTwo: 'J2EE', skillThree: 'PPT' &#125;, regeditTime: new Date(), interest: []&#125;var workmate3 = &#123; name: 'MinJie', age: 18, sex: 0, job: 'UI', skill: &#123; skillOne: 'PhotoShop', skillTwo: 'UI', skillThree: 'PPT' &#125;, regeditTime: new Date(), interest: []&#125;var workmate4 = &#123; name: 'XiaoWang', age: 25, sex: 1, job: 'UI', skill: &#123; skillOne: 'PhotoShop', skillTwo: 'UI', skillThree: 'PPT' &#125;, regeditTime: new Date(), interest: []&#125;var workmate5 = &#123; name: 'LiangPeng', age: 28, sex: 1, job: '前端', skill: &#123; skillOne: 'HTML+CSS', skillTwo: 'JavaScript', &#125;, regeditTime: new Date(), interest: []&#125;var workmate6 = &#123; name: 'HouFei', age: 25, sex: 0, job: '前端', skill: &#123; skillOne: 'HTML+CSS', skillTwo: 'JavaScript', &#125;, regeditTime: new Date(), interest: []&#125;var workmate7 = &#123; name: 'LiuYan', age: 35, sex: 0, job: '美工', skill: &#123; skillOne: 'PhotoShop', skillTwo: 'CAD', &#125;, regeditTime: new Date(), interest: []&#125;var workmate8 = &#123; name: 'DingLu', age: 20, sex: 0, job: '美工', skill: &#123; skillOne: 'PhotoShop', skillTwo: 'CAD', &#125;, regeditTime: new Date(), interest: []&#125;var workmate9 = &#123; name: 'JiaPeng', age: 29, sex: 1, job: '前端', skill: &#123; skillOne: 'HTML+CSS', skillTwo: 'JavaScript', skillThree: 'PHP' &#125;, regeditTime: new Date(), interest: []&#125;var workmate10 = &#123; name: 'LiJia', age: 26, sex: 0, job: '前端', skill: &#123; skillOne: 'HTML+CSS', skillTwo: 'JavaScript', skillThree: 'PHP' &#125;, regeditTime: new Date(), interest: []&#125;var db = connect('company');var workmateArray = [workmate1, workmate2, workmate3, workmate4, workmate5, workmate6, workmate7, workmate8, workmate9, workmate10];db.workmate.insert(workmateArray);print('[SUCCESS]：The data was inserted successfully'); 简单查找1234//简单查找db.workmate.find();//根据条件查找db.workmate.find(&#123; "skill.skillOne": "HTML+CSS" &#125;, &#123; name: true &#125;); 不等修饰符 小于($lt):英文全称 less-than 小于等于($lte)：英文全称 less-than-equal 大于($gt):英文全称 greater-than 大于等于($gte):英文全称 greater-than-equal 不等于($ne):英文全称 not-equal 可以根据不等修饰符进行查询。 12345//查找年龄小于30大于25岁的人db.workmate.find( &#123; age: &#123; $lte: 30, $gte: 25 &#125; &#125;, &#123; name: true, age: true, "skill.skillOne": true, _id: false &#125;) $in修饰符可以进行一个键多个值的查询。 12345//查找年龄为25和33的人db.workmate.find( &#123; age: &#123; $in: [25, 33] &#125; &#125;, &#123; name: 1, _id: 0 &#125;) $or修饰符同时进行多个键值的查询。或逻辑。 12345678910//查找年龄大于30或第三项技能为PHP的人db.workmate.find( &#123; $or: [ &#123; age: &#123; $gte: 30 &#125; &#125;, &#123; "skill.skillThree": "PHP" &#125; ] &#125;, &#123; name: 1, age: 1, "skill.skillThree": 1, _id: 0 &#125;) $and修饰符同时进行多个键值的查询。与逻辑。 12345678910//查找年龄大于30并且第三项技能为PHP的人db.workmate.find( &#123; $and: [ &#123; age: &#123; $gte: 30 &#125; &#125;, &#123; "skill.skillThree": "PHP" &#125; ] &#125;, &#123; name: 1, age: 1, "skill.skillThree": 1, _id: 0 &#125;) find在js文本中的使用使用find进行查询也可以像之前使用update操作一样，将语句写在一个js文件中，然后通过load方法执行该js文件即可。 1234567var db = connect('company');var result = db.workmate.find();while(result.hasNext()) &#123; printjson(result.next());&#125;//打印查询到的所有记录 除了使用while循环，也可以使用forEach，更加方便优雅。 123456var db = connect('company');var result = db.workmate.find();result.forEach(function(res) &#123; printjson(res);&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mongo学习笔记（二）]]></title>
    <url>%2F2018%2F02%2F21%2Fmongo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[学习mongoDB的修改(update)操作。 昨晚跟朋友出去浪了，没有继续学习，只能今天学习然后更下博客啦。 今天照着技术胖的博客继续学习了mongoDB的更新操作。 首先先把例子前提搭好：12345678910111213141516 var workmate =&#123; name:'Mike', age:20, sex:1, job:'UI设计', skill:&#123; skillOne:'PhotoShop', SkillTwo:'UI', SkillThree:'Word+Excel+PPT' &#125;, regeditTime:new Date()&#125;var db = connect('company');//创建company数据库db.workmate.insert(workmate);//新建workmate集合 $set修改器用来修改一个指定的键值(key)。1db.workmate.update(&#123;name: "Mike"&#125;, &#123;$set:&#123;age:22&#125;&#125;); 而对于文档内嵌文档的修改方式。使用点操作符 1db.workmate.update(&#123;name: "Mike"&#125;, &#123;$set: &#123;"skill.SkillThree": "word"&#125;&#125;); $unset修改器用于删除指定的key 1db.workmate.update(&#123;name: "Mike"&#125;, &#123;$unset: &#123;age: ''&#125;&#125;); $inc修改器对数据进行修改 12db.workmate.update(&#123;name: "Mike"&#125;, &#123;$inc: &#123;age: -2&#125;&#125;);//直接减2得到想要的数字。这里想要得到18，而原本是20 multi为所有的数据都添加上一个字段。设置multi为true，否则只为第一个数据增加了字段 1db.workmate.update(&#123;&#125;, &#123;$set: &#123;interest: []&#125;&#125;, &#123;multi: true&#125;); 此时所有数据都添加上了interest这个字段。 upsert当需要新增数据时，upsert在找不到值的情况下，可以直接插入这条数据。设置upsert为true 1db.workmate.update(&#123;name: "John"&#125;, &#123;$set: &#123;age: 20&#125;&#125;, &#123;upsert: true&#125;); 运行结果显示，新增了John这一行数据。 $push用于操作数组 12db.workmate.update(&#123;name: "John"&#125;, &#123;$push: &#123;interest: 'draw'&#125;&#125;);//为interest数组新增了'draw'的元素 $ne$ne主要的作用是，检查一个值是否存在，如果不存在再执行操作，存在就不执行。 12db.workmate.update(&#123; name: "John", interest: &#123; $ne: "playGame" &#125; &#125;, &#123; $push: &#123; interest: "Game" &#125; &#125;);//如果interest中有playGame，则不添加Game。否则添加 $addToSet查找是否存在，不存在就push上去。相比$ne更容易理解。 12db.workmate.update(&#123; name: "John" &#125;, &#123; $addToSet: &#123; interest: "readBook" &#125; &#125;)//interest数组中不存在'readBook'，则将'readBook'添加上 $each修改器它可以传入一个数组，一次增加多个值进去。 12var newInterset = ["Sing", "Dance", "Code"];db.workmate.update(&#123; name: "John" &#125;, &#123; $addToSet: &#123; interest: &#123; $each: newInterset &#125; &#125; &#125;) $pop用于删除数组值。 $pop只删除一次，并不是删除所有数组中的值。而且它有两个选项，一个是1和-1。 1：从数组尾部进行删除 -1：从数组头部进行删除 1db.workmate.update(&#123; name: 'John' &#125;, &#123; $pop: &#123; interest: 1 &#125; &#125;) 接下来看一点高级的12db.workmate.update(&#123;sex: 1&#125;, &#123;$set: &#123;money: 1000&#125;&#125;, false, true);//上面一句等同于这一句：db.workmate.update(&#123;sex: 1&#125;, &#123;$set: &#123;money: 1000&#125;&#125;, &#123;upsert: false&#125;, &#123;multi: true&#125;); 与之有异曲同工之妙的如下语句 123456789var myModify = &#123; findAndModify: 'workmate',//需要查找或修改的集合 query: 'Mike',//指定哪条数据 update: &#123;$set: &#123;age: 29&#125;&#125;,//进行修改 new: true //返回更新前的文档(false)还是更新后的文档(true)&#125;var resultMessage = db.runCommand(myModify);//使用runCommand来执行语句printjson(resultMessage);//以json形式打印结果 runCommand可以执行数据库操作的语句 两者都是执行更新操作，但是后者的安全性能相对较高，更加值得学习。]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mongo学习笔记(一)]]></title>
    <url>%2F2018%2F02%2F20%2Fmongo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[开始学习mongoDB。 MongoDB简介 MongoDB是一个基于分布式文件存储的数据库，由C++语言编写。目的是为WEB应用提供扩展的高性能的数据存储解决方案。MongoDB是一个介于关系型数据库和非关系型数据库之间的产品，是非关系型数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。 开始安装MongoDB安装步骤： 去官网下载MongoDB，https://www.mongodb.com/，在网站中找到Download按钮进行下载。 下载后进行安装，默认配置一直安装下去就可以了。 安装完成后，需要配置“环境变量”，目的是再命令行中直接使用，而不需要输入很长的路径。 运行MongoDB服务端安装好MongoDB数据库后，我们需要启用服务端才能使用。启用服务的命令是mongod。打开命令行，执行mongod。在命令中直接输入mongod，但是你会发现服务并没有启动，报了一个exception，服务停止了。这是因为我们需要在安装盘的根目录，建立data/db,这两个mongodb需要文件夹。新建所需文件夹之后再次运行mongod，这时候服务就可以开启了，链接默认端口是27017。 链接MongoDB服务端开启MongoDB服务器之后，我们需要进行链接。命令行操作为mongo。 一些常用的mongo基本命令我们都知道关系型的数据库，如mysql，oracle等都是采用SQL语句进行数据库增删查改的。而非关系型数据库中的佼佼者MongoDB则采用前端人员熟知的JavaScript语言进行数据库操作。可以来一段代码看看： 1234function tobee() &#123; return "welcome to tobee's blog";&#125;print(tobee()); //使用print进行打印而不能再使用console.log 一些基础命令show dbs —— 查看存在的数据库。原始存在admin和local两个数据库db.version() —— 查看数据库版本db —— 显示当前使用的数据库的名称use XXX —— 切换至某个数据库（若没有，则新建）show collection —— 查看数据库的集合db.集合.insert() —— 新建数据集合和插入文件。如db.user.insert({&quot;name&quot;:&quot;tobee&quot;})db.集合.find() —— 查询所有数据db.集合.update({查询条件}，{修改条件}) —— 修改文件数据db.集合.remove(条件) —— 删除文件数据。如db.user.remove({&quot;name&quot;:&quot;tobee&quot;}) 用js文件写mongo命令我们如果在命令行对我们数据库中的文件增删查改的话，会发现操作起来十分麻烦。这时候我们可以将需要操作的命令全部写在一个js文件中，再用mongo命令执行就可以了。 新建test.js，在其中新建一个数据库 1var db = connect("user"); //有则连接，没有则创建 终端执行命令 1mongo test.js 此时js文件中的mongo命令会被执行。 今天下午就先学这些，巩固下。晚上再继续学继续更新。对了，我是在技术胖的博客上学习的，超棒，推荐给大家。http://jspang.com/2017/12/16/mongdb/]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[重拾git]]></title>
    <url>%2F2018%2F02%2F20%2F%E9%87%8D%E6%8B%BEgit%2F</url>
    <content type="text"><![CDATA[来聊聊git。从我接触git开始算起应该是有半年多的时间了，那时候需要帮学校朋友的一个小项目写一个移动端网页然后让大家可以访问，后来了解到GitHub page就可以做到无需购买域名和服务器就可以帮我们托管自己的网站。所以我开始学习git然后现在重新回想下记录下来。 git Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds(Linux的发明者) 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 一步一步来 先登录GitHub，手动创建新仓库，并复制新的git地址 首先在目的目录下，右键进入git bash 然后git init初始化，让文件夹变成git可管理的仓库git add文件名 ：将指定文件上传至暂存区git commit -m 相关信息 ：将暂存区内容提交到主分支上此时若是第一次使用git上传文件，会提示进行相关内容的配置git config --global user.email &quot;your @example.com&quot;git config --global user.name &quot;your name&quot;git remote rm origingit remote add origin &quot;git地址&quot;：将分支与远程仓库地址进行关联git push -u origin master ：将本地仓库文件提交到远程仓库 此时若发现没有权限，需要公钥 ssh-keygen -t rsa -C &quot;邮箱&quot; (一路回车) 在GitHub的setting界面左边点选SSH and GPG keys，右上角选News SSH key 打开c:/user/administer/.ssh/目录(因人而异哦)，打开id_rsa.pub文件，将其复制到GitHub的key中，title任意输入此时可以开始提交文件至远程仓库，即git push -u origin master git clone git地址 ：git克隆项目 一些错误解决方法 提示出错信息：fatal: remote origin already exists输入git remote rm origin，再输入git remote add origin &quot;git地址&quot;。或者直接push 当远程仓库有一些本地文件没有的文件时，也会报错。此时先全部pull下来，再重新push上去 更多的git教程可参考廖雪峰的官方教程→Git教程]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[杂想]]></title>
    <url>%2F2018%2F02%2F19%2F%E6%9D%82%E6%83%B3%2F</url>
    <content type="text"><![CDATA[大年初四。just try it今天花了一个下午还有晚上的时间利用hexo和GitHub page搭建了属于自己的博客并对其做了个性化的DIY，同时也进行了前两篇博客的撰写，之后可能要买个域名将其解析到GitHub page上。接下来，我会将以前在没有博客的时候总结的一些学习上的坑都用博客的方式重新记录下来，勉励自己，同时也希望帮到别人，哪怕一个人。而且接下来的学习生涯也会在博客上留下我的足迹。 祝大家新年快乐。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[对hexo中Next主题的DIY]]></title>
    <url>%2F2018%2F02%2F19%2F%E5%AF%B9hexo%E4%B8%ADNext%E4%B8%BB%E9%A2%98%E7%9A%84DIY%2F</url>
    <content type="text"><![CDATA[总要有点追求，年轻人。在搭建好了自己的博客之后，发现网上有很多大神都自己DIY了这个Next主题。于是我翻阅了好几篇文章还有Hexo和Next的官方文档之后，开始着手进行这个主题的DIY。 文章主页添加阴影打开\themes\next\source\css\_custom\custom.styl，向里面加入： 1234567.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 在右上角或者左上角实现fork me on github→字母版→图案版挑选自己喜欢的样式，并复制代码。然后粘贴刚才复制的代码到themes/next/layout/_layout.swig文件中(放在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;的下面)，并把href改为你的github地址。 添加动态背景如果next主题在5.1.1以上的话就可以简单点设置，直接在主题配置文件_config.yml中找到canvas_nest: false或者three_waves:false，把它相应改为true就行了（注意分号后面要加一个空格）。 实现点击界面出现桃心效果在网址输入如下http://7u2ss1.com1.z0.glb.clouddn.com/love.js然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。将love.js文件放到路径/themes/next/source/js/src里面，然后打开\themes\next\layout\_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码：12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 在网站底部加上访问量打开主题配置文件\themes\next\_config.yml，在其中找到busuanzi_count，将参数enable改为true。接着在文件\themes\next\layout\_partials\footer.swig中的合适位置上加上如下参考代码，12345&lt;div class="powered-by"&gt;&lt;i class="fa fa-user-md"&gt;&lt;/i&gt;&lt;span id="busuanzi_container_site_uv"&gt; 本站访客数:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 网站底部字数统计在命令行使用npm安装hexo-wordcount1npm install hexo-wordcount --save 然后在/themes/next/layout/_partials/footer.swig文件尾部加上：1234&lt;div class="theme-info"&gt; &lt;div class="powered-by"&gt;&lt;/div&gt; &lt;span class="post-count"&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 实现统计功能在命令行使用npm安装hexo-wordcount1npm install hexo-wordcount --save 然后在主题的配置文件_config.yml中，配置如下： # Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true 参考来源（感谢~）http://blog.csdn.net/qq_33699981/article/details/72716951http://www.cduyzh.com/hexo-settings-4/]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[遇见hexo]]></title>
    <url>%2F2018%2F02%2F19%2F%E9%81%87%E8%A7%81hexo%2F</url>
    <content type="text"><![CDATA[一篇水水的技术分享。大佬勿喷大概很久之前就想拥有属于自己的博客了，自己是想完全靠自己搭建一个包括网站源代码，域名服务器购买，网站备案都由自己搞定，但是总是没时间后来就忘记了。之后听说Hexo可以帮我们搭建属于自己的博客而且也没有其他现有博客那么多限制，可以自己DIY。于是我就跟着hexo官方文档还有Next主题的官方文档一步一步搭建起现在的这个博客。接下来分享一些搭建时候的心路历程。 HEXO Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。这里我选用的是GitHub。如果想要更加全面的了解Hexo，可以到其官网了解更多的细节。 下载node，git在下载git的过程中不要点击“仅仅使用git bash”，点击“与Windows命令行结合”，本人遇到的坑就在这里，使用命令行输入稍后将要输入的命令hexo d进行部署的时候报了错，需要在git bash输入这句语句才有效。 GitHub page的配置去到GitHub新增一个仓库，名字跟用户名一样，如“yourname.github.io”。 用SSH keys关联Hexo与Github Pages在git bash中输入语句ssh-keygen -t rsa -C &quot;注册Git的邮箱地址&quot;。接着会生成一个密钥，去到存放这个密钥的文件夹中找到id_rsa.pub，如“C:\Users\Administrator.ssh”，将其中内容复制粘贴到https://github.com/settings/ssh 的 new SSH key中。接着输入ssh -T git@github.com查看是否设置成功。 新建文件夹放置博客内容在命令行使用npm安装hexo，步骤如下：12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 此时在浏览器中打开http://localhost:4000/ 就可以浏览博客了。 配置Deployment在_config.yml文件中，找到Deployment，然后按照如下修改： # Deployment## Docs:https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 本地文件提交到Git Pages12345678910// 删除旧的 public 文件hexo clean// 生成新的 public 文件hexo generate或者hexo g// 开始部署hexo deploye或者hexo d 需要安装一个扩展 npm install hexo-deployer-git --save然后在浏览器中输入 https:/yourname.github.io （用户名改成你的）看到了 Hexo 与 GitHub Pages 已经成功关联了。至此博客就算搞定啦~ 致谢即将成为史上最具用户体验的Hexo+GitHub Pages搭建博客的教程]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
</search>
